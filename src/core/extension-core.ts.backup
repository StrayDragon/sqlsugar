import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { LanguageHandler, LanguageType, QuoteType } from './language-handler';
import { SQLsClientManager, DatabaseConnection } from './sqls-client-manager';
import { CommandManager } from './command-manager';
import { IndentationPatternAnalyzer } from '../indentationAnalyzer';
import { PreciseIndentSyncManager } from './precise-indent-sync';

/**
 * 临时文件信息接口
 */
interface TempFileInfo {
    uri: vscode.Uri;
    originalEditor: vscode.TextEditor;
    originalSelection: vscode.Selection;
    originalQuotedSQL: string;
    lastSyncedContent: string;
    quoteType: QuoteType;
    language: LanguageType;
    disposables: vscode.Disposable[];
    isProcessing: boolean;
}

/**
 * 开发指标接口
 */
interface DevMetrics {
    activeDisposables: number;
    activeTempFiles: number;
    totalCommandInvocations: number;
}

/**
 * SQLSugar核心扩展管理器
 * 协调整个扩展的功能和生命周期
 */
export class ExtensionCore {
    private static instance: ExtensionCore | undefined;
    private context: vscode.ExtensionContext;
    private languageHandler: LanguageHandler;
    private sqlsClientManager: SQLsClientManager;
    private commandManager: CommandManager;
    private indentationAnalyzer: IndentationPatternAnalyzer;
    private preciseIndentSync: PreciseIndentSyncManager;

    // 临时文件管理
    private tempFiles: Map<string, TempFileInfo> = new Map();
    private devMetrics: DevMetrics;

    private constructor(context: vscode.ExtensionContext) {
        this.context = context;
        this.languageHandler = new LanguageHandler();
        this.sqlsClientManager = new SQLsClientManager(context);
        this.commandManager = new CommandManager(context);
        this.indentationAnalyzer = new IndentationPatternAnalyzer();
        this.preciseIndentSync = new PreciseIndentSyncManager();

        this.devMetrics = {
            activeDisposables: 0,
            activeTempFiles: 0,
            totalCommandInvocations: 0
        };

        this.initialize();
    }

    /**
     * 获取单例实例
     */
    public static getInstance(context?: vscode.ExtensionContext): ExtensionCore {
        if (!ExtensionCore.instance) {
            if (!context) {
                throw new Error('ExtensionCore instance not initialized and no context provided');
            }
            ExtensionCore.instance = new ExtensionCore(context);
        }
        return ExtensionCore.instance;
    }

    /**
     * 重置单例实例（用于测试环境）
     */
    public static resetInstance(): void {
        if (ExtensionCore.instance) {
            ExtensionCore.instance.dispose();
            ExtensionCore.instance = undefined;
        }
    }

    /**
     * 初始化扩展
     */
    private initialize(): void {
        // 注册所有命令
        this.commandManager.registerCommands();

        // 启动SQLs客户端
        this.sqlsClientManager.startClient().catch(error => {
            console.error('Failed to start SQLs client:', error);
        });

        // 初始化数据库连接
        this.sqlsClientManager.initializeConnection().catch(error => {
            console.error('Failed to initialize connection:', error);
        });

        // 注册事件监听器
        this.registerEventListeners();

        // 注册开发者命令
        this.registerDeveloperCommands();
    }

    /**
     * 注册事件监听器
     */
    private registerEventListeners(): void {
        // 监听文档关闭事件，清理临时文件
        this.context.subscriptions.push(
            vscode.workspace.onDidCloseTextDocument((doc) => {
                this.cleanupTempFile(doc.uri);
            })
        );

        // 监听窗口关闭事件
        this.context.subscriptions.push(
            vscode.window.onDidCloseTerminal((terminal) => {
                // 清理与终端相关的资源
            })
        );
    }

    /**
     * 注册开发者命令
     */
    private registerDeveloperCommands(): void {
        // 获取指标命令已在CommandManager中注册
    }

    /**
     * 创建临时SQL文件
     */
    public async createTempSQLFile(
        originalEditor: vscode.TextEditor,
        originalSelection: vscode.Selection,
        originalQuotedSQL: string
    ): Promise<vscode.Uri> {
        console.log('createTempSQLFile called with:', originalQuotedSQL);
        const language = this.languageHandler.detectLanguage(originalEditor.document);
        const quoteType = this.languageHandler.detectQuoteType(originalQuotedSQL);
        const sqlContent = this.languageHandler.stripQuotes(originalQuotedSQL);
        console.log('Stripped content:', sqlContent);

        // 转换ORM占位符为sqls兼容格式
        const { convertedSQL, hasPlaceholders } = this.convertPlaceholdersToTemp(sqlContent);
        console.log('Converted SQL:', convertedSQL, 'Has placeholders:', hasPlaceholders);

        // 创建临时文件
        let workspacePath = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        console.log('Initial workspacePath:', workspacePath);

        // If no workspace folder is found, try to use the document's directory
        if (!workspacePath && originalEditor.document.uri.scheme === 'file') {
            workspacePath = path.dirname(originalEditor.document.uri.fsPath);
            console.log('Using document directory:', workspacePath);
        }

        // If still no path, use current working directory as fallback
        if (!workspacePath) {
            workspacePath = process.cwd();
            console.log('Using cwd as fallback:', workspacePath);
        }

        // Special handling for test environment: ensure we use the test workspace
        if (process.env.VSCODE_TEST) {
            // Check if the document is in a test workspace
            const docDir = path.dirname(originalEditor.document.uri.fsPath);
            if (docDir.includes('test-workspace')) {
                workspacePath = docDir;
                console.log('Test environment detected, using test workspace:', workspacePath);
            }
        }

        const tempDir = path.join(workspacePath, '.vscode/sqlsugar/temp');
        console.log('Temp directory will be:', tempDir);

        if (!fs.existsSync(tempDir)) {
            console.log('Temp directory does not exist, creating it...');
            fs.mkdirSync(tempDir, { recursive: true });
            console.log('Temp directory created successfully:', tempDir);
        } else {
            console.log('Temp directory already exists:', tempDir);
        }

        const tempFileName = `temp_sql_${Date.now()}.sql`;
        const tempFilePath = path.join(tempDir, tempFileName);
        const tempUri = vscode.Uri.file(tempFilePath);

        // 写入临时文件内容
        const fileContent = this.generateTempFileContent(convertedSQL, hasPlaceholders);
        await vscode.workspace.fs.writeFile(tempUri, Buffer.from(fileContent, 'utf8'));

        // 保存临时文件信息
        const tempFileInfo: TempFileInfo = {
            uri: tempUri,
            originalEditor,
            originalSelection,
            originalQuotedSQL,
            lastSyncedContent: originalQuotedSQL, // 初始化为原始内容
            quoteType,
            language,
            disposables: [],
            isProcessing: false
        };

        this.tempFiles.set(tempUri.fsPath, tempFileInfo);
        this.devMetrics.activeTempFiles++;

        // 初始化精确缩进同步器
        const originalSQL = this.languageHandler.stripQuotes(originalQuotedSQL);
        if (originalSQL.includes('\n')) {
            this.preciseIndentSync.createTracker(
                tempUri.fsPath,
                originalSQL
            );
        }

        // 注册临时文件保存监听器 - 只在用户主动保存时同步
        const disposable = vscode.workspace.onDidSaveTextDocument((e) => {
            console.log('Text document saved event:', e.uri.fsPath);
            console.log('Temp file path:', tempUri.fsPath);
            console.log('Matches:', e.uri.fsPath === tempUri.fsPath);

            if (e.uri.fsPath === tempUri.fsPath) {
                console.log('Temp file saved detected, triggering sync...');
                this.handleTempFileChange(tempFileInfo);
            }
        });

        tempFileInfo.disposables.push(disposable);

        return tempUri;
    }

    /**
     * 生成临时文件内容
     */
    private generateTempFileContent(sql: string, hasPlaceholders: boolean): string {
        // 直接返回SQL内容，不添加任何额外的提示信息
        return sql;
    }

    /**
     * 处理临时文件变化
     */
    private async handleTempFileChange(tempFileInfo: TempFileInfo): Promise<void> {
        if (tempFileInfo.isProcessing) {
            console.log('Sync already in progress, skipping');
            return;
        }

        tempFileInfo.isProcessing = true;

        try {
            // 检查原始编辑器是否仍然打开
            if (!tempFileInfo.originalEditor || tempFileInfo.originalEditor.document.isClosed) {
                console.log('Original editor is closed, skipping sync');
                return;
            }

            const doc = await vscode.workspace.openTextDocument(tempFileInfo.uri);
            const modifiedSQL = doc.getText();

            // 转换回ORM占位符格式
            let finalSQL = this.convertPlaceholdersFromTemp(modifiedSQL);

            // 对于Python多行SQL，使用精确缩进同步保留原始缩进
            if (tempFileInfo.language === 'python' && finalSQL.includes('\n')) {
                // 使用精确缩进同步器
                finalSQL = this.preciseIndentSync.syncIndent(
                    tempFileInfo.uri.fsPath,
                    finalSQL
                );
            }

            // 获取原始的引号类型和前缀
            const originalQuote = this.languageHandler.detectQuoteType(tempFileInfo.originalQuotedSQL);
            const prefix = this.languageHandler.extractPrefix(tempFileInfo.originalQuotedSQL);

            // 智能包装内容（根据内容升级引号类型）
            const wrappedContent = this.languageHandler.wrapLikeIntelligent(tempFileInfo.originalQuotedSQL, finalSQL, tempFileInfo.language);

            // 验证选择范围仍然有效
            const currentDocument = tempFileInfo.originalEditor.document;
            const currentSelection = tempFileInfo.originalSelection;

            // 检查选择范围是否仍然有效
            let targetSelection = currentSelection;
            const currentSelectedText = currentDocument.getText(currentSelection);

            // 如果当前选择的内容与上次同步的内容不匹配，尝试查找上次同步内容的位置
            if (currentSelectedText !== tempFileInfo.lastSyncedContent) {
                const fullText = currentDocument.getText();

                // Try to find the last synced content by searching for unique patterns
                // This avoids partial matches that cause duplication
                const searchStr = tempFileInfo.lastSyncedContent;
                let originalIndex = -1;

                // Strategy 1: Look for exact match with word boundaries
                const escapedOriginal = searchStr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const exactRegex = new RegExp(`\\b${escapedOriginal}\\b`, 'm');
                const exactMatch = fullText.match(exactRegex);

                if (exactMatch && exactMatch.index !== undefined) {
                    originalIndex = exactMatch.index;
                } else {
                    // Strategy 2: Use lastIndexOf to find the most recent occurrence
                    // This helps avoid finding partial matches in newly added content
                    originalIndex = fullText.lastIndexOf(searchStr);
                }

                // Validation: ensure the match is not a partial substring
                if (originalIndex !== -1) {
                    const beforeChar = originalIndex > 0 ? fullText[originalIndex - 1] : '';
                    const afterChar = originalIndex + searchStr.length < fullText.length ?
                                     fullText[originalIndex + searchStr.length] : '';

                    // Check if it's a standalone match (not part of a larger string)
                    const isValidMatch = (
                        (beforeChar === '' || /\s/.test(beforeChar) || beforeChar === '=' || beforeChar === '(') &&
                        (afterChar === '' || /\s/.test(afterChar) || afterChar === ';' || afterChar === ')')
                    );

                    if (!isValidMatch) {
                        originalIndex = -1; // Reset if not a valid match
                    }
                }

                if (originalIndex !== -1) {
                    // 找到上次同步的内容，更新选择范围
                    const startPos = currentDocument.positionAt(originalIndex);
                    const endPos = currentDocument.positionAt(originalIndex + tempFileInfo.lastSyncedContent.length);
                    targetSelection = new vscode.Selection(startPos, endPos);
                }
            }

            // 再次检查编辑器是否仍然有效
            if (tempFileInfo.originalEditor.document.isClosed) {
                console.log('Original editor closed before edit, skipping sync');
                return;
            }

            // 替换选中的内容
            await tempFileInfo.originalEditor.edit(editBuilder => {
                editBuilder.replace(targetSelection, wrappedContent);
            });

            // 更新上次同步的内容
            tempFileInfo.lastSyncedContent = wrappedContent;
        } catch (error) {
            console.error('Sync error:', error);
            vscode.window.showErrorMessage(`Failed to sync changes: ${error}`);
        } finally {
            tempFileInfo.isProcessing = false;
        }
    }

    /**
     * 转换ORM占位符为临时格式
     */
    private convertPlaceholdersToTemp(sql: string): { convertedSQL: string; hasPlaceholders: boolean } {
        // 匹配ORM占位符，但不匹配PostgreSQL类型转换(::type)或时间格式(12:34:56)
        const placeholderRegex = /:(?!\d+)\w+/g;
        let hasPlaceholders = false;
        let convertedSQL = sql;

        if (placeholderRegex.test(sql)) {
            hasPlaceholders = true;
            convertedSQL = sql.replace(placeholderRegex, (match, offset, str) => {
                // 检查前面是否是:: (PostgreSQL类型转换)
                if (offset > 0 && str[offset - 1] === ':') {
                    return match; // 不转换PostgreSQL类型转换
                }
                // 检查是否是时间格式中的冒号
                if (offset > 0 && /\d/.test(str[offset - 1])) {
                    return match; // 不转换时间格式中的冒号
                }
                return '__:' + match.substring(1); // 转换ORM占位符
            });
        }

        return { convertedSQL, hasPlaceholders };
    }

    /**
     * 转换临时占位符回ORM格式
     */
    private convertPlaceholdersFromTemp(sql: string): string {
        const tempPlaceholderRegex = /__:(\w+)/g;
        return sql.replace(tempPlaceholderRegex, ':$1');
    }

    /**
     * 应用缩进模式到SQL内容
     */
    private applyIndentationPattern(sql: string, pattern: any): string {
        console.log('DEBUG applyIndentationPattern:', {
            patternType: pattern.type,
            baseIndent: JSON.stringify(pattern.baseIndent),
            lineTypesCount: pattern.lineTypes?.size || 0,
            sqlLines: sql.split('\n').length
        });

        const lines = sql.split('\n');
        const result: string[] = [];

        lines.forEach((line, index) => {
            const trimmed = line.trim();
            if (!trimmed) {
                // 保留空行但移除缩进
                result.push('');
                return;
            }

            // 根据行类型确定缩进
            const lineType = this.classifyLineType(trimmed, lines, index);
            console.log('DEBUG applyIndentationPattern line:', {
                index,
                trimmed,
                lineType,
                isAND: trimmed.startsWith('AND '),
                isOR: trimmed.startsWith('OR ')
            });
            const indent = this.getIndentationForLine(lineType, pattern, lines, index);

            result.push(indent + trimmed);
        });

        return result.join('\n');
    }

    /**
     * 分类行类型
     */
    private classifyLineType(trimmedLine: string, lines: string[], index: number): string {
        const firstWord = trimmedLine.split(/\s+/)[0].toUpperCase();
        const sqlKeywords = new Set([
            'SELECT', 'FROM', 'WHERE', 'AND', 'OR', 'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER',
            'GROUP', 'ORDER', 'HAVING', 'LIMIT', 'UNION', 'INSERT', 'UPDATE', 'DELETE',
            'WITH'
        ]);

        if (sqlKeywords.has(firstWord)) {
            return 'keyword';
        } else if (trimmedLine.startsWith('--')) {
            return 'comment';
        } else if (this.isContinuationLine(lines, index)) {
            return 'continuation';
        } else {
            return 'content';
        }
    }

    /**
     * 检查是否为延续行
     */
    private isContinuationLine(lines: string[], index: number): boolean {
        if (index === 0) {
            return false;
        }

        const prevLine = lines[index - 1].trim();
        const currentLine = lines[index].trim();

        return prevLine.endsWith(',') ||
               prevLine.endsWith('+') ||
               prevLine.endsWith('||') ||
               (prevLine.length > 0 && !prevLine.endsWith(';') &&
                currentLine.length > 0 && !this.isKeywordLine(currentLine));
    }

    /**
     * 检查是否为关键字行
     */
    private isKeywordLine(line: string): boolean {
        const firstWord = line.split(/\s+/)[0].toUpperCase();
        const sqlKeywords = new Set([
            'SELECT', 'FROM', 'WHERE', 'AND', 'OR', 'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER',
            'GROUP', 'ORDER', 'HAVING', 'LIMIT', 'UNION', 'INSERT', 'UPDATE', 'DELETE',
            'WITH'
        ]);
        return sqlKeywords.has(firstWord);
    }

    /**
     * 获取行的缩进
     */
    private getIndentationForLine(lineType: string, pattern: any, lines: string[], index: number): string {
        // 基于原始模式类型确定缩进
        switch (pattern.type) {
            case 'uniform':
                return pattern.baseIndent;

            case 'hierarchical':
                return this.getHierarchicalIndent(lineType, pattern, lines, index);

            case 'keyword-aligned':
                return this.getKeywordAlignedIndent(lineType, pattern);

            case 'continuation':
                return this.getContinuationIndent(lineType, pattern, lines, index);

            case 'mixed':
            case 'none':
            default:
                // 对于混合或无模式，尝试保持原始缩进
                return this.getConsistentIndent(lineType, pattern, lines, index);
        }
    }

    /**
     * 获取分层缩进
     */
    private getHierarchicalIndent(lineType: string, pattern: any, lines: string[], index: number): string {
        switch (lineType) {
            case 'WHERE':
                return pattern.baseIndent + '  ';
            case 'AND':
            case 'OR':
                // First check keyword alignments for existing AND/OR patterns
                const keywordAlignments = pattern.keywordAlignments as Map<string, number> || new Map();
                const whereIndent = keywordAlignments.get('WHERE') || pattern.baseIndent.length;
                const andIndent = keywordAlignments.get('AND');

                console.log('DEBUG getHierarchicalIndent for AND/OR:', {
                    lineType,
                    whereIndent,
                    andIndent,
                    baseIndentLength: pattern.baseIndent.length,
                    willUseKeywordAlignments: andIndent !== undefined && andIndent > whereIndent
                });

                if (andIndent !== undefined && andIndent > whereIndent) {
                    console.log('DEBUG using keyword alignments for AND/OR, returning', andIndent, 'spaces');
                    return ' '.repeat(andIndent);
                }

                // Also check for AND/OR patterns in the line content
                const lineTypes = pattern.lineTypes as Map<number, string> || new Map();
                const lineIndents = pattern.lineIndents as Map<number, string> || new Map();

                for (const [i, type] of lineTypes.entries()) {
                    const line = lines[i] || '';
                    const trimmed = line.trim();

                    // Check for AND/OR patterns that might have extra indentation
                    if ((type === 'content' || type === 'keyword' || type === 'continuation') &&
                        (trimmed.startsWith('AND ') || trimmed.startsWith('OR '))) {
                        const indent = lineIndents.get(i);
                        if (indent && indent.length > pattern.baseIndent.length) {
                            return indent;
                        }
                    }
                }

                // Fallback: use 2 extra spaces (common pattern)
                return pattern.baseIndent + '  ';
            case 'JOIN':
            case 'LEFT':
            case 'RIGHT':
            case 'INNER':
            case 'OUTER':
                return pattern.baseIndent;
            case 'SELECT':
            case 'FROM':
            case 'GROUP BY':
            case 'ORDER BY':
            case 'HAVING':
                return pattern.baseIndent;
            case 'continuation':
                return pattern.levels[1] || pattern.baseIndent + '    ';
            default:
                return pattern.baseIndent;
        }
    }

    /**
     * 获取关键字对齐缩进
     */
    private getKeywordAlignedIndent(lineType: string, pattern: any): string {
        const keywordAlignments = pattern.keywordAlignments;

        switch (lineType) {
            case 'WHERE':
                return ' '.repeat(keywordAlignments.get('WHERE') || pattern.baseIndent.length + 2);
            case 'AND':
            case 'OR':
                return ' '.repeat((keywordAlignments.get('WHERE') || pattern.baseIndent.length) + 2);
            case 'FROM':
                return ' '.repeat(keywordAlignments.get('FROM') || pattern.baseIndent.length);
            case 'JOIN':
                return ' '.repeat(keywordAlignments.get('FROM') || pattern.baseIndent.length);
            default:
                return pattern.baseIndent;
        }
    }

    /**
     * 获取延续缩进
     */
    private getContinuationIndent(lineType: string, pattern: any, lines: string[] = [], index: number = 0): string {
        if (lineType === 'continuation') {
            return ' '.repeat(pattern.continuationIndent);
        }

        // Handle AND/OR conditions in continuation patterns
        if (lineType === 'AND' || lineType === 'OR') {
            // First check keyword alignments for existing AND/OR patterns
            const keywordAlignments = pattern.keywordAlignments as Map<string, number> || new Map();
            const whereIndent = keywordAlignments.get('WHERE') || pattern.baseIndent.length;
            const andIndent = keywordAlignments.get('AND');

            console.log('DEBUG getContinuationIndent for AND/OR:', {
                lineType,
                whereIndent,
                andIndent,
                baseIndentLength: pattern.baseIndent.length,
                willUseKeywordAlignments: andIndent !== undefined && andIndent > whereIndent
            });

            if (andIndent !== undefined && andIndent > whereIndent) {
                console.log('DEBUG using keyword alignments for AND/OR, returning', andIndent, 'spaces');
                return ' '.repeat(andIndent);
            }

            // Also check for AND/OR patterns in the line content
            const lineTypes = pattern.lineTypes as Map<number, string> || new Map();
            const lineIndents = pattern.lineIndents as Map<number, string> || new Map();

            for (const [i, type] of lineTypes.entries()) {
                const line = lines[i] || '';
                const trimmed = line.trim();

                // Check for AND/OR patterns that might have extra indentation
                if ((type === 'content' || type === 'keyword' || type === 'continuation') &&
                    (trimmed.startsWith('AND ') || trimmed.startsWith('OR '))) {
                    const indent = lineIndents.get(i);
                    if (indent && indent.length > pattern.baseIndent.length) {
                        console.log('DEBUG found existing AND/OR pattern in line content, returning', JSON.stringify(indent));
                        return indent;
                    }
                }
            }

            // Fallback: use 2 extra spaces (common pattern)
            console.log('DEBUG using fallback for AND/OR, returning baseIndent + 2 spaces');
            return pattern.baseIndent + '  ';
        }

        return pattern.baseIndent;
    }

    /**
     * 获取一致的缩进
     */
    private getConsistentIndent(lineType: string, pattern: any, lines: string[], index: number): string {
        // 尝试找到最一致的缩进模式
        if (lineType === 'continuation') {
            // 对于延续行，查找最长的缩进
            const maxIndent = Math.max(...pattern.levels.map((level: string) => level.length));
            return ' '.repeat(maxIndent);
        }

        // 对于关键字行，使用基础缩进
        if (lineType === 'keyword') {
            return pattern.baseIndent;
        }

        // 对于其他行，使用第二级缩进（如果有的话）
        return pattern.levels[1] || pattern.baseIndent + '    ';
    }

    /**
     * 清理临时文件
     */
    private cleanupTempFile(uri: vscode.Uri): void {
        const tempInfo = this.tempFiles.get(uri.fsPath);
        if (tempInfo) {
            // 清理所有disposables
            tempInfo.disposables.forEach(d => d.dispose());
            this.tempFiles.delete(uri.fsPath);
            this.devMetrics.activeTempFiles--;

            // 清理精确缩进同步器
            this.preciseIndentSync.cleanupTracker(uri.fsPath);

            // 删除临时文件
            const tempFileCleanup = vscode.workspace.getConfiguration('sqlsugar').get<boolean>('tempFileCleanup', true);
            const cleanupOnClose = vscode.workspace.getConfiguration('sqlsugar').get<boolean>('cleanupOnClose', true);

            // 在测试环境中禁用自动删除，确保测试可以找到临时文件
            if (tempFileCleanup && cleanupOnClose && !process.env.VSCODE_TEST) {
                vscode.workspace.fs.delete(uri).then(undefined, err => {
                    console.error('Failed to delete temp file:', err);
                });
            } else if (process.env.VSCODE_TEST) {
                console.log('Test environment detected, skipping automatic cleanup of temp file:', uri.fsPath);
            }
        }
    }

    /**
     * 获取开发指标
     */
    public getMetrics(): DevMetrics {
        return { ...this.devMetrics };
    }

    /**
     * 销毁扩展资源
     */
    public dispose(): void {
        // 清理临时文件
        this.tempFiles.forEach((tempInfo, path) => {
            tempInfo.disposables.forEach(d => d.dispose());
            try {
                vscode.workspace.fs.delete(vscode.Uri.file(path));
            } catch (error) {
                console.error('Failed to delete temp file:', error);
            }
            // 清理精确缩进同步器
            this.preciseIndentSync.cleanupTracker(path);
        });

        this.tempFiles.clear();

        // 清理其他资源
        this.sqlsClientManager.dispose();

        // 更新指标
        this.devMetrics.activeDisposables = 0;
        this.devMetrics.activeTempFiles = 0;
    }

    // 公共访问方法
    public getLanguageHandler(): LanguageHandler {
        return this.languageHandler;
    }

    public getSQLsClientManager(): SQLsClientManager {
        return this.sqlsClientManager;
    }

    public getCommandManager(): CommandManager {
        return this.commandManager;
    }
}